<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <title>The HTML5 Herald</title>
    <meta name="description" content="Route information" />
    <meta name="author" content="Damian Terlecki" />
    <link rel="stylesheet" type="text/css" href="main.css">
    <script src="https://www.google.com/jsapi"></script>
</head>

<body>
    BODY

    <input type="file" id="files" name="files" />
    <output id="list"></output>

    <div id="map">

    </div>
    <div id="elevation_chart"></div>
    <div id="weather"></div>
    <div id="drag"></div>
    <div id="angles"></div>


    <!--    <script src="https://maps.googleapis.com/maps/api/js?callback=initMap" async defer></script>-->
    <script src="xmlToJson.js"></script>

    <script>
        function isFileApiSupported() {
            return (window.File && window.FileReader && window.FileList && window.Blob);
        }

        function handleFileSelect(evt) {
            if (!isFileApiSupported) {
                alert('The File APIs are not fully supported by your browser.');
                return null;
            }

            var file = evt.target.files[0];
            if (file) {
                var reader = new FileReader(),
                    text,
                    xml,
                    json;

                reader.onload = function(e) {
                    text = e.target.result;
                    xml = parseXml(text);
                    if (xml) {
                        json = xmlToJson(xml);


                        var trkpts = json.gpx.trk.trkseg.trkpt;
                        routeCoordinates = [];
                        routeAngles = [];
                        for (var i = 0; i < trkpts.length; i++) {
                            var trkpt = {
                                lat: parseFloat(trkpts[i]["@attributes"]["lat"]),
                                lng: parseFloat(trkpts[i]["@attributes"]["lon"])
                            }
                            if (i === 0) {
                                centerCoordinates = {
                                    lat: trkpt.lat,
                                    lng: trkpt.lng
                                }
                            } else {
                                var p0 = {
                                        y: routeCoordinates[i - 1].lat,
                                        x: routeCoordinates[i - 1].lng
                                    },
                                    p1 = {
                                        y: trkpt.lat,
                                        x: trkpt.lng
                                    }
                                var southAngle = (calculateAngleDeg(p0, p1) + 90) * (-1.0);
                                while (southAngle < 0.0) {
                                    southAngle += 360.0;
                                }
                                var sectionAngle = {
                                    angle: southAngle,
                                    distance: calculateDistance(p0, p1)
                                }
                                routeAngles.push(sectionAngle);

                            }
                            routeCoordinates.push(trkpt);
                        }
                        loadAPI();
                    } else {
                        alert("Failed to parse xml file.")
                    }
                }
                reader.readAsText(file);

            } else {
                alert("Failed to load file.");
            }
            return json;
        }

        function loadAPI() {
            var script = document.createElement("script");
            script.src = "https://maps.googleapis.com/maps/api/js?callback=initMap";
            script.type = "text/javascript";
            document.getElementsByTagName("head")[0].appendChild(script);
        }

        var map;
        var routeCoordinates;
        var centerCoordinates;
        var routeAngles;

        google.load('visualization', '1', {
            packages: ['columnchart']
        });

        function initMap() {
            var map = new google.maps.Map(document.getElementById('map'), {
                zoom: 8,
                center: centerCoordinates,
                mapTypeId: 'terrain'
            });

            var routePolyline = new google.maps.Polyline({
                path: routeCoordinates,
                geodesic: true,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 2
            });

            routePolyline.setMap(map);


            // Create an ElevationService.
            var elevator = new google.maps.ElevationService;

            // Draw the path, using the Visualization API and the Elevation service.
            displayPathElevation(routeCoordinates, elevator, map);

            getWeather();
        }


        document.getElementById('files').addEventListener('change', handleFileSelect, false);




        //ELEVATION
        function displayPathElevation(path, elevator, map) {
            // Display a polyline of the elevation path.
            new google.maps.Polyline({
                path: path,
                strokeColor: '#0000CC',
                opacity: 0.4,
                map: map
            });

            // Create a PathElevationRequest object using this array.
            // Ask for 256 samples along that path.
            // Initiate the path request.
            elevator.getElevationAlongPath({
                'path': path,
                'samples': 512
            }, plotElevation);
        }

        // Takes an array of ElevationResult objects, draws the path on the map
        // and plots the elevation profile on a Visualization API ColumnChart.
        function plotElevation(elevations, status) {
            var chartDiv = document.getElementById('elevation_chart');
            if (status !== 'OK') {
                // Show the error code inside the chartDiv.
                chartDiv.innerHTML = 'Cannot show elevation: request failed because ' +
                    status;
                return;
            }
            // Create a new chart in the elevation_chart DIV.
            var chart = new google.visualization.ColumnChart(chartDiv);

            // Extract the data from which to populate the chart.
            // Because the samples are equidistant, the 'Sample'
            // column here does double duty as distance along the
            // X axis.
            var data = new google.visualization.DataTable();
            data.addColumn('string', 'Sample');
            data.addColumn('number', 'Elevation');
            for (var i = 0; i < elevations.length; i++) {
                data.addRow(['', elevations[i].elevation]);
            }

            // Draw the chart using the data within its DIV.
            chart.draw(data, {
                height: 150,
                legend: 'none',
                titleY: 'Elevation (m)'
            });
        }


        var personSpeed = 30;



        //WEATHER
        function getWeather() {
            return getJson("http://api.openweathermap.org/data/2.5/weather?lat=" + centerCoordinates.lat + "&lon=" + centerCoordinates.lng + "&APPID=95c13d1ccbcc0775dee571bc0f63e716",
                function(error, data) {
                    if (error != null) {
                        alert("Error while retrieving weather data: " + err);
                    } else {
                        var weatherDiv = document.getElementById('weather');
                        weatherDiv.innerHTML = weatherDiv.innerHTML + JSON.stringify(data);

                        var windSpeed = ktToKph(data["wind"]["speed"]),
                            windAngle = data["wind"]["deg"],
                            temperature = data["main"]["temp"],
                            pressure = data["main"]["pressure"] * 100,
                            humidity = data["main"]["humidity"] / 100,
                            airDensity = calculateAirDensity(pressure, temperature, humidity),
                            coeff = new CityCyclist(),
                            dragForce = calculateDragForce((30 - windSpeed) * 1000 / 3600, coeff.Cd, coeff.A, airDensity),

                            dragDiv = document.getElementById('drag');
                        weatherDiv.innerHTML = weatherDiv.innerHTML + "Drag force: " + dragForce + "N";

                        var totalHeadwind = 0.0;
                        var totalDistance = 0.0;
                        for (var i = 0; i < routeAngles.length; i++) {
                            var headwind = calculateHeadwind(windAngle, routeAngles[i].angle, windSpeed),
                                crosswind = calculateCrosswind(windAngle, routeAngles[i].angle, windSpeed),
                                dragSpeed = personSpeed + headwind,
                                totalSpeed = personSpeed - headwind;
                            dragForce = calculateDragForce(kphToMps(dragSpeed), coeff.Cd, coeff.A, airDensity);

                            console.log("Wind angle: " + windAngle + " Heading angle: " + routeAngles[i].angle + " wind: " + windSpeed + " headwind: " + headwind + " crosswind: " + crosswind);
                            routeAngles[i].headwind = headwind;
                            routeAngles[i].crossWind = crosswind;
                            routeAngles[i].dragSpeed = dragSpeed;
                            routeAngles[i].totalSpeed = totalSpeed;
                            var anglesDiv = document.getElementById('angles');
                            anglesDiv.innerHTML = anglesDiv.innerHTML + "Angle: " + routeAngles[i].angle + " Distance: " + routeAngles[i].distance + " HW: " + headwind + " CW: " + crosswind + " DS: " + dragSpeed + " TS: " + totalSpeed + "dragF: " + dragForce + "<br>";

                            totalHeadwind += routeAngles[i].distance * headwind;
                            totalDistance += routeAngles[i].distance;
                        }
                        totalHeadwind /= totalDistance;
                        anglesDiv.innerHTML = anglesDiv.innerHTML + "<br>Average headwind: " + totalHeadwind;
                    }
                });
        }

        function ktToKph(kt) {
            return 1.852 * kt;
        }

        function kphToMps(kph) {
            return kph * 1000 / 3600;
        }

        function calculateHeadwind(windAngleDeg, headingAngleDeg, windSpeed) {
            var alphaDeg = windAngleDeg - headingAngleDeg;
            return -Math.cos(toRadians(alphaDeg)) * windSpeed;
        }

        function calculateCrosswind(windAngleDeg, headingAngleDeg, windSpeed) {
            var alphaDeg = windAngleDeg - headingAngleDeg;
            return Math.sin(toRadians(alphaDeg)) * windSpeed;
        }

        function calculateAngleDeg(p0, p1) {
            var dx = p1.x - p0.x,
                dy = p1.y - p0.y;
            return toDegrees(Math.atan2(dy, dx));
        }

        function toDegrees(radians) {
            return radians * (180 / Math.PI);
        }

        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }

        function calculateDistance(p0, p1) {
            var dx = p1.x - p0.x,
                dy = p1.y - p0.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        var getJson = function(url, callback) {
            var xhr = new XMLHttpRequest();
            xhr.open("get", url, true);
            xhr.responseType = "json";
            xhr.onload = function() {
                var status = xhr.status;
                if (status == 200) {
                    callback(null, xhr.response);
                } else {
                    callback(status);
                }
            };
            xhr.send();
        };

        //https://en.wikipedia.org/wiki/Density_of_air
        //[(Pa*kg/mol)/((JK)/(K*mol))] = [(N*kg)/((kg*m^3*s^2)/s^2)] = [kg/m^3]
        function calculateAirDensity(p, T, phi, R = 8.314) {
            var Md = 0.028964,
                Mv = 0.018016,
                psat = 6.1078 * Math.pow(10, (7.5 * kelvinToCelsius(T)) / (kelvinToCelsius(T) + 237.3)) * 100,
                pv = phi * psat,
                pd = p - pv;
            return (pd * Md + pv * Mv) / (R * T);
        }

        function kelvinToCelsius(T) {
            return T - 273.15;
        }

        //https://en.wikipedia.org/wiki/Drag_equation
        //[(kg/m^3) * (m^2/s^2) * m2] = [kg * m/s^2] = [N]
        function calculateDragForce(v, Cd, A, p = 1.293) {
            return 0.5 * p * v * v * Cd * A;
        }

        //Values for Cyclist in "Tops" position from "Bicycling Science" (Wilson, 2004)
        function CityCyclist() {
            this.Cd = 1.15;
            this.A = 0.632;
        };

        //Values for Cyclist in "Drops" position from "The effect of crosswinds upon time trials" (Kyle,1991)
        function RacingCyclist() {
            this.Cd = 0.88;
            this.A = 0.32;
        };

        //Values based on the data from Penwarden, A.D., P.F. Grigg, and R. Rayment. 1978. Measurement of wind drag on people standing in a wind tunnel. Building Environ. 13: 75-84.
        function Runner() {
            this.Cd = 1.27;
            this.A = 0.55;
        };

    </script>
</body>

</html>
